/**
 * <auto-generated>
 * Autogenerated by Thrift Compiler (0.22.0)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 * </auto-generated>
 */
using System;

// targeting netstandard 2.x
#if(! NETSTANDARD2_0_OR_GREATER)
#error Unexpected target platform. See 'thrift --help' for details.
#endif

#pragma warning disable IDE0079  // remove unnecessary pragmas
#pragma warning disable IDE0017  // object init can be simplified
#pragma warning disable IDE0028  // collection init can be simplified
#pragma warning disable IDE0305  // collection init can be simplified
#pragma warning disable IDE0034  // simplify default expression
#pragma warning disable IDE0066  // use switch expression
#pragma warning disable IDE0090  // simplify new expression
#pragma warning disable IDE0290  // use primary CTOR
#pragma warning disable IDE1006  // parts of the code use IDL spelling
#pragma warning disable CA1822   // empty DeepCopy() methods still non-static
#pragma warning disable IDE0083  // pattern matching "that is not SomeType" requires net5.0 but we still support earlier versions

/// <summary>
/// Encodings supported by Parquet.  Not all encodings are valid for all types.  These
/// enums are also used to specify the encoding of definition and repetition levels.
/// See the accompanying doc for the details of the more complicated encodings.
/// </summary>
public enum Encoding
{
  /// <summary>
  /// Default encoding.
  /// BOOLEAN - 1 bit per value. 0 is false; 1 is true.
  /// INT32 - 4 bytes per value.  Stored as little-endian.
  /// INT64 - 8 bytes per value.  Stored as little-endian.
  /// FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
  /// DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
  /// BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
  /// FIXED_LEN_BYTE_ARRAY - Just the bytes.
  /// </summary>
  PLAIN = 0,
  /// <summary>
  /// Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
  /// plain type.
  /// in a data page use RLE_DICTIONARY instead.
  /// in a Dictionary page use PLAIN instead
  /// </summary>
  PLAIN_DICTIONARY = 2,
  /// <summary>
  /// Group packed run length encoding. Usable for definition/repetition levels
  /// encoding and Booleans (on one bit: 0 is false; 1 is true.)
  /// </summary>
  RLE = 3,
  /// <summary>
  /// Bit packed encoding.  This can only be used if the data has a known max
  /// width.  Usable for definition/repetition levels encoding.
  /// </summary>
  BIT_PACKED = 4,
  /// <summary>
  /// Delta encoding for integers. This can be used for int columns and works best
  /// on sorted data
  /// </summary>
  DELTA_BINARY_PACKED = 5,
  /// <summary>
  /// Encoding for byte arrays to separate the length values and the data. The lengths
  /// are encoded using DELTA_BINARY_PACKED
  /// </summary>
  DELTA_LENGTH_BYTE_ARRAY = 6,
  /// <summary>
  /// Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
  /// Suffixes are stored as delta length byte arrays.
  /// </summary>
  DELTA_BYTE_ARRAY = 7,
  /// <summary>
  /// Dictionary encoding: the ids are encoded using the RLE encoding
  /// </summary>
  RLE_DICTIONARY = 8,
  /// <summary>
  /// Encoding for fixed-width data (FLOAT, DOUBLE, INT32, INT64, FIXED_LEN_BYTE_ARRAY).
  /// K byte-streams are created where K is the size in bytes of the data type.
  /// The individual bytes of a value are scattered to the corresponding stream and
  /// the streams are concatenated.
  /// This itself does not reduce the size of the data but can lead to better compression
  /// afterwards.
  /// 
  /// Added in 2.8 for FLOAT and DOUBLE.
  /// Support for INT32, INT64 and FIXED_LEN_BYTE_ARRAY added in 2.11.
  /// </summary>
  BYTE_STREAM_SPLIT = 9,
}
